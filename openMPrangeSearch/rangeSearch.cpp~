//#include <mpi.h>
#include <omp.h>
#include <stdlib.h>
#include <iostream>
#include <string>
//#include <cmath>
//#include <fstream>

#include <stdio.h>
#include <time.h>
#include "ESBTL_ProteinHandler.h"

#include "miscFunctions.h"
#include "dataStructures.h"
#include <string>

#include "cpuBruteForceSearch.h"
#include "cpuKdTreeSearch.h"
using namespace std;


/*
void processSingleKdTreeRangeSearch(rangeSearchSettings& settings, ProteinDataHandler heldProteinSets, AtomToNumHashTable atomReferenceTable, int set, int currentEntry)
{
    int i =set;
    int numberOfProcessedFiles = currentEntry;
	int outputType = settings.resultsPrintFormat;
	outputHandler filePrinter;
	std::string printType;
//	std::cout << "PERFORMING KD TREE RANGE SEARCH" << std::endl;
	int soughtAtomANumber = atomReferenceTable.retrieveHashValue(settings.AtomTypeOne);
	int soughtAtomBNumber = atomReferenceTable.retrieveHashValue(settings.AtomTypeTwo);
	int maxDistanceSquared = settings.requiredProximity*settings.requiredProximity;
	int allocatedSearchSize = 16384 * sizeof(int) * 4;
	int* atomAPositionList = (int*)malloc(sizeof(int) * 16384);
	int* atomACount = (int*)malloc(sizeof(int) * 1);
	int* completionFlag = (int*)malloc(sizeof(int) * 1);
	int* atomAMatches = (int*)malloc(sizeof(int) * 16384);
	int* atomBMatches = (int*)malloc(sizeof(int) * 16384);

	atomACount[0] = 0;
	for (int i = 0; i < 16384; i++)
	{
		atomAMatches[i] = -1;
		atomBMatches[i] = -1;
		atomAPositionList[i] = -1;
	}

    clock_t n, m;
    n = clock();

        searchEntryInSecondaryPositionStructureForAtom(soughtAtomANumber, currentEntry, heldProteinSets.ProteinDataHolder[i].MaxEntrySize, heldProteinSets.ProteinDataHolder[i].compositionCountsList, heldProteinSets.ProteinDataHolder[i].compositionLists, heldProteinSets.ProteinDataHolder[i].compositionPointers, atomAPositionList, atomACount);
        if (atomACount[0] > 0)
        {
            int resultsSize = 0;
            for (int p = 0; p < atomACount[0]; p++)
            {
                std::vector<int> resultsVector;
                int *runCount = (int*)malloc(sizeof(int));
                runCount[0] = 0;

                atomCoords atomACoords;
                setAtomCoords(atomACoords, heldProteinSets.ProteinDataHolder[i].xCoordsSets[atomAPositionList[p]], heldProteinSets.ProteinDataHolder[i].yCoordsSets[atomAPositionList[p]], heldProteinSets.ProteinDataHolder[i].zCoordsSets[atomAPositionList[p]]);
                rangeSearchCpu(atomACoords, soughtAtomBNumber, settings.requiredProximity, resultsVector, heldProteinSets.ProteinDataHolder[i].namesSets, heldProteinSets.ProteinDataHolder[i].xCoordsSets, heldProteinSets.ProteinDataHolder[i].yCoordsSets, heldProteinSets.ProteinDataHolder[i].zCoordsSets, heldProteinSets.ProteinDataHolder[i].kdTrees, heldProteinSets.ProteinDataHolder[i].KdTreeSize, 0, 0, runCount, heldProteinSets.ProteinDataHolder[i].MaxEntrySize*currentEntry, heldProteinSets.ProteinDataHolder[i].KdTreeSize*currentEntry);
                for (int j = 0; j < resultsVector.size(); j++) //All atomB will be related to the atomA being searched for in the greater loop
                {
                    resultsSize = resultsSize + 1;
                    if (outputType == 2)
                    {
                        std::cout << "Atom A: " << heldProteinSets.ProteinDataHolder[i].namesSets[atomAPositionList[p]] << "\t - Pos : " << (atomAPositionList[p] - heldProteinSets.ProteinDataHolder[i].MaxEntrySize*currentEntry) << "\t X: " << ((double(heldProteinSets.ProteinDataHolder[i].xCoordsSets[atomAPositionList[p]])) / 1000) << "\t Y: " << ((double(heldProteinSets.ProteinDataHolder[i].yCoordsSets[atomAPositionList[p]])) / 1000) << "\t Z: " << ((double(heldProteinSets.ProteinDataHolder[i].zCoordsSets[atomAPositionList[p]])) / 1000) << std::endl;
                        std::cout << "Atom B: " << heldProteinSets.ProteinDataHolder[i].namesSets[heldProteinSets.ProteinDataHolder[i].MaxEntrySize * currentEntry + resultsVector[j]] << "\t - Pos : " << resultsVector[j] << "\t X: " << ((double(heldProteinSets.ProteinDataHolder[i].xCoordsSets[heldProteinSets.ProteinDataHolder[i].MaxEntrySize * currentEntry + resultsVector[j]])) / 1000) << "\t Y: " << ((double(heldProteinSets.ProteinDataHolder[i].yCoordsSets[heldProteinSets.ProteinDataHolder[i].MaxEntrySize * currentEntry + resultsVector[j]])) / 1000) << "\t Z: " << ((double(heldProteinSets.ProteinDataHolder[i].zCoordsSets[heldProteinSets.ProteinDataHolder[i].MaxEntrySize * currentEntry + resultsVector[j]])) / 1000) << std::endl << std::endl;
                    }
                }
            }
            if (outputType == 1 || outputType == 2)
                std::cout << "Number of matches in file " << numberOfProcessedFiles << " in set " << i << "  is: " << resultsSize << std::endl;
        }
        else
        {
            if (outputType == 1 || outputType == 2)
                std::cout << "Number of matches in file " << numberOfProcessedFiles << " in set " << i << "  is: 0" << std::endl;
        }
    

    m = clock();
    if (settings.debugLevel>0)
    print_elapsed(n, m, "time to process file subset: ");
    filePrinter.closeOpenFile();
}

void processSingleFile(rangeSearchSettings &settings, ProteinDataHandler heldProteinSets, AtomToNumHashTable atomReferenceTable, int rangeToProcess, int entryToProcess)
{
    outputHandler filePrinter;
    int outputType = settings.resultsPrintFormat;
    int i = rangeToProcess;
    int currentEntry = entryToProcess;

    int soughtAtomANumber = atomReferenceTable.retrieveHashValue(settings.AtomTypeOne);
    int soughtAtomBNumber = atomReferenceTable.retrieveHashValue(settings.AtomTypeTwo);
    int maxDistanceSquared = settings.requiredProximity*settings.requiredProximity;

    int* atomAPositionList = (int*)malloc(sizeof(int) * 16384/4*4);
    int* atomBPositionList = (int*)malloc(sizeof(int) * 16384/4*4);
    int* atomACount = (int*)malloc(sizeof(int) * 1);
    int* nextSearchCount = (int*)malloc(sizeof(int) * 1);
    int* completionFlag = (int*)malloc(sizeof(int) * 1);
    int* MatchesCount = (int*)malloc(sizeof(int) * 1);
    int* atomAMatches = (int*)malloc(sizeof(int) * 16384/4*4);
    int* atomBMatches = (int*)malloc(sizeof(int) * 16384/4*4);
    int* atomBCount = (int*)malloc(sizeof(int) * 1);


        clock_t n,m;

    if ((heldProteinSets.ProteinDataHolder[i].heldEntries>0)&&(currentEntry<heldProteinSets.ProteinDataHolder[i].heldEntries))
    {
       // std::cout << std::endl;
       // std::cout << "Processing Range set: " << i << std::endl;
       // std::cout << "Number of present entries is: " << heldProteinSets.ProteinDataHolder[i].heldEntries << std::endl;

        int numberOfProcessedFiles = 0;
  
        n=clock();


        searchEntryInSecondaryPositionStructureForAtom(soughtAtomANumber, currentEntry, heldProteinSets.ProteinDataHolder[i].MaxEntrySize, heldProteinSets.ProteinDataHolder[i].compositionCountsList, heldProteinSets.ProteinDataHolder[i].compositionLists, heldProteinSets.ProteinDataHolder[i].compositionPointers, atomAPositionList, atomACount);
        searchEntryInSecondaryPositionStructureForAtom(soughtAtomBNumber, currentEntry, heldProteinSets.ProteinDataHolder[i].MaxEntrySize, heldProteinSets.ProteinDataHolder[i].compositionCountsList, heldProteinSets.ProteinDataHolder[i].compositionLists, heldProteinSets.ProteinDataHolder[i].compositionPointers, atomBPositionList, atomBCount);

        if ((atomACount[0] > 0) && (atomBCount[0] > 0))
        {
            int resultsSize = 0;
            for (int p = 0; p < atomACount[0]; p++)
            {

                std::vector<int> resultsVector;

                atomCoords atomACoords;
                setAtomCoords(atomACoords, heldProteinSets.ProteinDataHolder[i].xCoordsSets[atomAPositionList[p]], heldProteinSets.ProteinDataHolder[i].yCoordsSets[atomAPositionList[p]], heldProteinSets.ProteinDataHolder[i].zCoordsSets[atomAPositionList[p]]);

                bruteForceSearchCpu(atomACoords, atomBPositionList, atomBCount, maxDistanceSquared, heldProteinSets,resultsVector,i);


                for (int j = 0; j < resultsVector.size(); j++) //All atomB will be related to the atomA being searched for in the greater loop
                {
                    resultsSize = resultsSize + 1;
                    if (outputType == 2)
                    {
                        std::cout << "Atom A: " << heldProteinSets.ProteinDataHolder[i].namesSets[atomAPositionList[p]] << "\t - Pos : " << (atomAPositionList[p] - heldProteinSets.ProteinDataHolder[i].MaxEntrySize*currentEntry) << "\t X: " << ((double(heldProteinSets.ProteinDataHolder[i].xCoordsSets[atomAPositionList[p]])) / 1000) << "\t Y: " << ((double(heldProteinSets.ProteinDataHolder[i].yCoordsSets[atomAPositionList[p]])) / 1000) << "\t Z: " << ((double(heldProteinSets.ProteinDataHolder[i].zCoordsSets[atomAPositionList[p]])) / 1000) << std::endl;
                        std::cout << "Atom B: " << heldProteinSets.ProteinDataHolder[i].namesSets[ resultsVector[j]] << "\t - Pos : " << (resultsVector[j] - currentEntry*heldProteinSets.ProteinDataHolder[i].MaxEntrySize) << "\t X: " << ((double(heldProteinSets.ProteinDataHolder[i].xCoordsSets[resultsVector[j]])) / 1000) << "\t Y: " << ((double(heldProteinSets.ProteinDataHolder[i].yCoordsSets[resultsVector[j]])) / 1000) << "\t Z: " << ((double(heldProteinSets.ProteinDataHolder[i].zCoordsSets[resultsVector[j]])) / 1000) << std::endl << std::endl;
                    }

                }



            }
            if (outputType == 1 || outputType == 2)
                std::cout << "Number of matches in file " << numberOfProcessedFiles << " in set " << i << "  is: " << resultsSize << std::endl;
                        numberOfProcessedFiles++;

        }
        else
        {
            if (outputType == 1 || outputType == 2)
                std::cout << "Number of matches in file " << numberOfProcessedFiles << " in set " << i << "  is: 0"  << std::endl;
                        numberOfProcessedFiles++;
        }


    }

    m=clock();
    if (settings.debugLevel>0)
    print_elapsed(n, m, "time to process file subset: ");
    filePrinter.closeOpenFile();

    free(atomAPositionList);
    free(atomBPositionList);
    free(atomACount);
    free(nextSearchCount);
    free(completionFlag);
    free(MatchesCount);
    free(atomAMatches);
    free(atomBMatches);
    free(atomBCount);

}
*/



int main(int argc, char** argv) {
//Main program

 clock_t start, stop;
 rangeSearchSettings currentSettings;
 std::string runSettingsFile = "runDetails.txt";
 loadRunDetails(runSettingsFile, currentSettings);
 start = clock();


std::cout<<"Number of files is: "<<currentSettings.numberOfFiles<<std::endl;
AtomToNumHashTable atomReferenceTable;
ProteinDataHandler heldProteinSets(currentSettings);


std::ifstream fileLoader;
fileLoader.open(currentSettings.inputListFileLocation.c_str());
vector<std::string> inputLocationsList;






inputLocationsList.resize(currentSettings.numberOfFiles);
for(int i=0;i<currentSettings.numberOfFiles;i++)
	fileLoader>>inputLocationsList[i];

//for(int i=0;i<50;i++)
//	std::cout<<inputLocationsList[i]<<std::endl;
//return 0;	
//std::cout<<currentSettings.inputListFileLocation;




//std::cout<<"made it to before the loop"<<std::endl;
start =clock();
/*#pragma omp parallel for shared(heldProteinSets) 
for(int i=0;i<currentSettings.numberOfFiles;i++)
{
//Load 1 file into memory
std::string fileToBeProcessed =inputLocationsList[i]; 
//std::cout<<"about to process entry "<<i<<std::endl;
heldProteinSets.loadSingleProteinToArraysOmp(atomReferenceTable,currentSettings , i, fileToBeProcessed);
}
stop=clock();
print_elapsed(start, stop, "Total build time: ");
*/
heldProteinSets.loadAllProteinsToArrays(currentSettings.inputListFileLocation, atomReferenceTable, currentSettings);
stop=clock();
print_elapsed(start, stop, "Total build time: ");



//OMP_Code_loading
{
//start=clock();
//heldProteinSets.nullSecondarySearchStructures();
//heldProteinSets.FormatSecondaryPositionStructuresOMP();
//stop = clock();
//print_elapsed(start, stop, "Secondary Structure construction time: ");
}

//non_OMP_codes
{
start=clock();
heldProteinSets.setSecondarySearchStructure();
stop = clock();
print_elapsed(start, stop, "Secondary Structure construction time: ");

start=clock();
constructKdTreesOnLoadedDataOnCPUOMP(heldProteinSets);
stop = clock();
print_elapsed(start, stop, "kd Tree construction time: ");

}
//cpuKdTreeRangeSearch(currentSettings, heldProteinSets, atomReferenceTable);
//heldProteinSets.DisplayHeldEntriesPerRange();
start=clock();

//cpuBruteForceRangeSearchAllLoadedSets(currentSettings, heldProteinSets, atomReferenceTable);
for(int r=0; r<5;r++)
{

start=clock();
for(int j=0;j<5;j++)
{
        std::cout << std::endl;
        std::cout << "Processing Range set: " << j << std::endl;
        std::cout << "Number of present entries is: " << heldProteinSets.ProteinDataHolder[j].heldEntries << std::endl;
#pragma omp parallel for 
for(int i=0;i<heldProteinSets.ProteinDataHolder[j].heldEntries; i++)
{
processSingleFile(currentSettings, heldProteinSets, atomReferenceTable, j, i);
}

}
stop = clock();
        print_elapsed(start, stop, " - - - - - Total run time for brute force: ");
       
}



for (int r=0; r<5; r++)
{
start=clock();
 std::cout << "PERFORMING KD TREE RANGE SEARCH" << std::endl;
for (int i = 0; i < 5; i++)
{
	if (heldProteinSets.ProteinDataHolder[i].heldEntries>0)
	{
		std::cout << std::endl;
		std::cout << "Processing Range set: " << i << std::endl;
		std::cout << "Number of present entries is: " << heldProteinSets.ProteinDataHolder[i].heldEntries << std::endl;
 //        	#pragma omp parallel for
		for (int currentEntry = 0; currentEntry < heldProteinSets.ProteinDataHolder[i].heldEntries; currentEntry++)
		{
	                processSingleKdTreeRangeSearch(currentSettings,  heldProteinSets,  atomReferenceTable, i, currentEntry);

        	}
        }
}


stop = clock();
	print_elapsed(start, stop, " = = = = = Total run time for kdTree: ");
}
	return 0;


//Example2
/*	int currentNum=0;
	int* list = (int*)malloc(sizeof(int)*12);
	for (int i=0;i<12;i++)
        	list[i]=9999; 
     #pragma omp parallel shared(list) num_threads(6)
        {
        int ID = omp_get_thread_num();
	//char numstr [10];
        //string outputFileName = "InputListForID";
        //sprintf(numstr, "%d", ID);
        //outputFileName += numstr;
        //outputFileName += ".txt";
	//list[ID]=ID;
	//ofstream myfile;
  	//myfile.open (outputFileName);
  	//myfile <<"bla \n";
  	int localVal;
  	#pragma omp atomic capture
	localVal= currentNum++;
  	//myfile <<list[ID];
  	list[ID]=localVal;
  	//myfile<<localVal;
	//myfile.close();
	}
ofstream lastFile;
lastFile.open("fullOutput.txt");
 for (int i=0;i<12;i++)
               lastFile<<list[i]<<" \n";
lastFile.close();
return 0;

*/

//Example1
/*int nn =4;
int* list = (int*)malloc(sizeof(int)*12); 
for (int i=0;i<12;i++)
	list[i]=i;
for (int i=0;i<12;i++)
        cout<<list[i]<<endl;
        


	#pragma omp parallel shared(list) num_threads(6)
	{
	int ID = omp_get_thread_num();
	int Total=0;
	//cout<<"ID is set to: "<<ID<<endl;
	Total=list[ID]+list[ID+6];
	cout<<"Thread "<<ID<<" has been initialised "<<std::endl;
	list[ID] =Total;	
	


	}
for(int i=0;i<12;i++)
	cout<<list[i]<<endl;
*/





//        int totalNumberOfFiles = checkNumberOfProteinFilesInList(RangeSearchSettings.inputListFileLocation);
//	std::cout<<totalNumberOfFiles<<endl;

	return 0;
}
